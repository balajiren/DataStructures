https://explainjava.com/simple-in-memory-cache-java/

//http://blog.gainlo.co/index.php/2016/05/17/design-a-cache-system/


WHY CACHE
========

1. NO WAY TO SCALE THE PERFORMANCE
2. CACHE CAN BE REPLICATED - GOOD READS BUT BAD WRITES, 

PARTITIONED - LINEAR SCALABLE,OWNERSHIP
FAILOVER - BACKING UP
LOCATION OF SERVER IS DYNAMIC

DISADVANTAGES
1. LATENCY - LOW READ SPEED WRITES
2. CAN BE SOLVED THROUGH LOCAL CACHE
    - EVICTION BY EVENT OR TIME EXPIRATION

 MIRRORED

DISTRIBUTED CACHE
=================

1. LRU CACHE

2.SUPPORT INSERT, DELETE AND LOOKUP

3. HASH TABLE WITH  QUE NODE IMPLEMENTED BY A DOUBLY LINKED LIST IS NEEDED

4. EVICTION - LFU ( LEAST FREQUENTLY USED )
              - TINYFLU - USAGE OVER A TIME
 LRU = KEEP ACCESS COUNTER WITHIN THE LAST N HOURS
 -------------------------------------------------
LEAST TIME BETWEEN ACCESS - WHEN VALUES IS ACCESS MARK THE TIME AND INCREASE ACCESS COUNT.
LEAST ACCESS EVICTION (PREFERRED)
----------------------------------
CALCULATE THE AVG. ACCESS TIME. EVICT THAT HAS A DROPPING AVERAGE ACCESS TIME
 ANOTHER VARIATION IS SET THE ACCESS COUNT HAS REACHED N, RESET IT AND INCREMENT THE TIME.
 ONLY CALCULATE THE TIME FOR LAST N ACCESS. WHEN ACCESS COUNT REACHES N RESET ACCESS COUNT TO 0
 AND RECORD THE ACCESS TIME
              
5. CONSISTANCY HASHING
RING ALLOWS MACHINES TO GET ADDED OR REMOVED
              
 CONCURRENCY
 ===========
 
 1. ONE APPROACH IS TO LOCK ONLY REQUIRED SEGMENTS
 
 2. ELSE LOG THE DATA AND THEN UPDATE USING A BACKGROUND PROCESS
 
 3. WRITE THROUGH CACHE ( ONLY WORKS FOR ONE SERVER CACHE)
 
 
 DISTRIBUTED CACHE
 =================
 1. DISTRIBUTE CACHE AMONG DIFFERENT CACHE NODES
  
  
 2. CAN USE TIME BASED EXPIRATION OR ACTIVE EXPIRATION ONLY FOR KEEPING THE CACHE IN SYNC 
 
